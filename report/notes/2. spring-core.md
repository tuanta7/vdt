# Spring

## 1. IoC - Inversion of Control

Inversion of Control (IoC) is a fundamental principle of software engineering used in object-oriented programming. It refers to a design pattern where the control flow of a program is inverted compared to traditional procedural programming.

- Instead of the application code controlling the flow of execution and creating dependencies, an external entity (such as a framework or container) takes over these responsibilities
- This external entity injects dependencies and manages the lifecycle of objects, promoting loose coupling and better manageability.

### Key Concepts of IoC

- **Dependency Injection (DI)**: injecting dependencies into an object rather than the object creating the dependencies itself. This can be done through constructor injection, setter injection, or field injection.
- **Service Locator Pattern**: an object uses a locator to find its dependencies

> DI is generally preferred over the Service Locator pattern for better maintainability and testability.

### Benefits

- **Decoupling**: By removing the responsibility of dependency management from the objects themselves, IoC reduces the coupling between components, making the system more modular and easier to maintain.
- **Testability**: With IoC, dependencies can be easily mocked or stubbed, enhancing the ability to write unit tests.
- **Flexibility**: It becomes easier to swap out implementations of a dependency, which can be useful for changing configurations or behaviors without modifying the dependent code.
- **Manageability**: The lifecycle and configuration of objects are centralized in the container, simplifying the overall management of the application.

## 2. Spring Container

In Spring, IoC is implemented through the `Spring IoC container`, which manages the creation, configuration, and lifecycle of application objects, known as `beans`. The Spring container acts as an **injector** in the context of Dependency Injection (DI)

### Key Concepts

- Bean Definition: The container uses bean definitions to create and configure beans. Bean definitions can be specified in XML configuration files (legacy), **Java annotations**, or **Java-based configuration classes**.
- Bean Lifecycle: The container is responsible for managing the entire lifecycle of beans, from instantiation to destruction. This includes dependency injection, initialization, and any required post-processing.
- Dependency Injection (DI): The container injects dependencies into beans, either through constructor injection, setter injection, or field injection, ensuring that beans are provided with the required dependencies.
- Scopes: Beans can have different scopes that determine their lifecycle and visibility within the application. Common scopes include `singleton`, `prototype`, `request`, `session`, and `global session`.

### Types

- **BeanFactory**: The BeanFactory is the simplest container, providing basic DI capabilities. It lazily instantiates beans, meaning beans are created only when they are requested. The BeanFactory is suitable for lightweight and simple applications.
- **ApplicationContext**: A more advanced container that builds on the `BeanFactory`

## 3. Dependency Injection

- When class A uses some functionality of class B, then its said that class A has a dependency of class B.
- In Java, before we can use methods of other classes, we first need to create the object of that class (i.e. class A needs to create an instance of class B).

➡️ Transferring the task of creating the object to someone else and directly using the dependency is called dependency injection.

![DI](./imgs/DI.png)

Source: [FreeCodeCamp](https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/)

### 3.1. Constructor Injection

> Constructor injection is preferred over field and setter injection because it makes it easier to create immutable objects and ensures that dependencies are not null.

The dependencies are provided through a class constructor. It is one of the most commonly used DI methods because it ensures that the bean is always in a fully initialized state when it is created.

- Use this when the dependencies is required
- Recommended by the spring.io development team as first choice

### 3.2. Setter Injection

The client exposes a setter method that the injector uses to inject the dependency. Setter injection allows for partial injection where some dependencies can be optional (not all dependencies need to be provided through the constructor, e.g: a `Student` doesn't have to join a `SoccerTeam`).

- Use this when you have optional dependencies
- If dependency is not provided, your app can provide reasonable default logic

### 3.3. Field Injection (not recommended)

The dependencies are injected directly into the class using the `@Autowired` annotation (the simplest approach).

```java
@Autowired
private final EmailService emailService;
```

- Field injection creates a risk of NullPointerException if dependencies aren't correctly initialized.
- Unable to create immutable classes (impossible to autowire the final fields using field injection).
- Single Responsibility Violation: We can easily add more dependencies than necessary and create a class that’s doing more than one job.

## 4. Spring Annotations

Spring will scan your Java classes for special annotaions: `@Component`,` @RestController`, etc.

- These classes (beans) are automatically registerd in the Spring container

### 4.1. The `@SpringBootApplication` annotation

Composesed of following annotations:

- `@EnableAutoConfiguration`: enables Spring Boot auto-configuration support
- `@ComponentScan`: enables conmponent scanning of current package, also recursively scan sub-packages
- `@Configuration`: able to register extra beans with `@Bean` or import ither configuration classes

We can explcitly list base packages to scan

```java
@SpringBootApplication(
    scanBasePackages = {
        "com.example.demo",
        "com.example.utils",
        "com.tuanta.utils"
    }
)
```

### 4.2. Spring Auto-wiring: `@AutoWired` & `@Qualifier`, `@Primary`

Spring Autowiring is a feature provided by the Spring Framework that allows for automatic dependency injection. By using autowiring, Spring can automatically satisfy the dependencies of a bean by injecting the required beans into it without the need for explicit configuration in XML or Java configuration classes.

The `@Autowired` annotation on the constructor indicates that the `EmailService` and `OptionalService` should be injected into `NotificationService` class

```java
@Component
public class NotificationService {
    private final EmailService emailService;
    private final OptionalService optionalService;

    // Constructor Injection
    @Autowired
    public NotificationService(EmailService emailService) {
        this.emailService = emailService;
    }

    // Setter Injection
    @Autowired
    public setOptionalService(OptionalService optionalService) {
        this.optionalService = emailService;
    }

    public void sendNotification(String message) {
        emailService.sendEmail(message);
    }
}
```

The `@Qualifier` annotation in Spring is used in conjunction with `@Autowired` (or other injection annotations like `@Inject`) to resolve ambiguity when multiple beans of the same type are available in the Spring context. By using `@Qualifier`, you can specify which exact bean should be injected.

```java
public interface NotificationService {
    void sendNotification(String message);
}

@Service("emailService")
public class EmailService implements NotificationService {
    @Override
    public void sendNotification(String message) {
        System.out.println("Email notification sent: " + message);
    }
}

@Service("smsService")
public class SmsService implements NotificationService {
    @Override
    public void sendNotification(String message) {
        System.out.println("SMS notification sent: " + message);
    }
}

@Component
public class NotificationManager {
    private NotificationService notificationService;

    @Autowired
    public void setNotificationService(@Qualifier("emailService") NotificationService notificationService) {
        this.notificationService = notificationService;
    }

    public void send(String message) {
        notificationService.sendNotification(message);
    }
}
```

### 4.3. Common Annotations Summary

#### Core, MVC & Configuration

| Annotations      | Desciption                                                                                                           |
| ---------------- | -------------------------------------------------------------------------------------------------------------------- |
| @Component       |                                                                                                                      |
| @Service         | A specialized `@Component` annotation, indicating that an annotated class is a service (business service)            |
| @Repository      | A specialized `@Component` annotation, indicating that an annotated class is a repository                            |
| @Controller      | A specialized `@Component` annotation, indicating that an annotated class is a Spring MVC controller.                |
| @RestController  | A convenience annotation that combines `@Controller` and `@ResponseBody`. It is used to create RESTful web services. |
| @RequestMapping  | Provides mapping information for controller methods, allowing them to be accessed via specific HTTP request paths.   |
| @[Method]Mapping | Shortcut annotations for @RequestMapping for specific HTTP methods: Get, Post, Put, Delete, Patch                    |
| @RequestParam    | Used to extract query parameters from the request.                                                                   |
| @PathVariable    | Used to extract values from the URI path: `{values}`                                                                 |
| ---------------  | ------------------------------------------------------------------------------------------------------------------   |
| @Bean            |                                                                                                                      |
| @Configuration   |                                                                                                                      |
| @PropertySource  |                                                                                                                      |

#### Injection

| Annotations | Desciption                                                                                                                                |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| @Value      | Used to inject values from a properties file into a bean's fields.                                                                        |
| @AutoWired  | Marks a constructor, field, setter method, or configuration method to be autowired by Spring's dependency injection facilities            |
| @Qualifier  | Used in conjunction with `@Autowired` to specify which bean should be injected when multiple candidates are possible                      |
| @Primary    | Designate a specific bean as the primary candidate when multiple beans of the same type are available (alternative to using `@Qualifier`) |

#### Aspect-Oriented Programming (AOP) Annotations

#### Transaction Management Annotations

## 5. Lazy Initialization

Lazy Initialization in Spring is a technique to delay the creation of a bean until it is first needed.

- By default, Spring creates and initializes all singleton beans at the startup of the application context.
- Sometimes it is beneficial to create beans only when they are required, which can improve startup time and resource usage, especially for beans that are resource-intensive or not always used.

### Types

- Class-Level Lazy Initialization

```java
@Component
@Lazy
public class ExpensiveService {
    public ExpensiveService() {
        System.out.println("ExpensiveService created");
    }

    public void performTask() {
        System.out.println("Performing a task in ExpensiveService");
    }
}
```

The ExpensiveService bean is annotated with @Lazy, meaning it won't be created until it's needed. In this case, the message "ExpensiveService created" will not be printed until the ExpensiveService bean is accessed.

- Field/Method-Level Lazy Initialization

```java
@Autowired
public ServiceConsumer(@Lazy ExpensiveService expensiveService) {
    this.expensiveService = expensiveService;
}
```

- Global Lazy Initialization

```java
@Configuration
@ComponentScan(basePackages = "com.example")
@Lazy
public class AppConfig {
}
```

## 6. Bean Scopes

In Spring, a bean's scope defines the lifecycle and visibility of that bean within the context of the container

- Different scopes can be used to manage how beans are created, stored, and shared within an application.
- Spring provides several built-in scopes, and you can also create custom scopes if needed.

### Built-in Bean Scopes in Spring

- **Singleton** (Default Scope): A single instance of the bean is created and shared across the entire Spring container. This is the default scope if no other scope is specified.
- **Prototype**: A new instance of the bean is created every time it is requested from the Spring container.

#### Web Application Scope

- **Request**: A single instance of the bean is created and available for the lifecycle of a single HTTP request. After the request is complete, the bean is discarded.
- **Session**: A single instance of the bean is created and available for the lifecycle of an HTTP session. After the session is complete, the bean is discarded.
- **Application**: A single instance of the bean is created and shared across the entire ServletContext. This is similar to the singleton scope but for web applications.
- **WebSocket**: A single instance of the bean is created and available for the lifecycle of a WebSocket session.

| Annotations                                        | Desciption                                               |
| -------------------------------------------------- | -------------------------------------------------------- |
| @Scope("prototype")                                | .                                                        |
| @Scope(WebApplicationContext.SCOPE_REQUEST)        |                                                          |
| @Scope(WebApplicationContext.SCOPE_SESSION)        |                                                          |
| @Scope(WebApplicationContext.SCOPE_APPLICATION)    |                                                          |
| @Scope(WebApplicationContext.SCOPE_GLOBAL_SESSION) | Similar to session scope but for global Portlet sessions |

### Bean Lifecycle

In Spring, beans go through a lifecycle that includes several phases: instantiation, dependency injection, initialization, and destruction. Spring provides various ways to hook into the lifecycle and execute custom code during the initialization and destruction phases. These hooks can be implemented using the following methods:

- Using `@PostConstruct` and `@PreDestroy` annotations
- Implementing `InitializingBean` and `DisposableBean` interfaces
- Specifying custom initialization and destruction methods in the configuration
